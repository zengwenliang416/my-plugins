#!/usr/bin/env bun
/**
 * Documentation Full Generator Script
 * Generates complete documentation based on plan.json
 */

import { readFile, writeFile, mkdir } from "fs/promises";
import { join, dirname } from "path";

interface DocItem {
  id: string;
  type: "api" | "component" | "guide" | "reference";
  path: string;
  title: string;
  source_files: string[];
  priority: string;
  status: string;
  estimated_sections: string[];
  dependencies: string[];
  complexity: string;
}

interface DocPlan {
  version: string;
  generated: string;
  project_root: string;
  documents: DocItem[];
  generation_order: string[];
}

interface GenerationStatus {
  last_run: string;
  documents: Record<
    string,
    {
      status: "generated" | "pending" | "failed";
      generated_at?: string;
      output_path: string;
      source_hash?: string;
      word_count?: number;
      error?: string;
    }
  >;
  statistics: {
    total: number;
    generated: number;
    pending: number;
    failed: number;
  };
}

const TEMPLATES: Record<string, string> = {
  api: `# {title}

## Overview

{overview}

## Authentication

This endpoint requires authentication via Bearer token.

## Endpoints

{endpoints}

## Examples

\`\`\`typescript
{example}
\`\`\`

## Error Codes

| Code | Description |
|------|-------------|
| 400 | Bad Request |
| 401 | Unauthorized |
| 404 | Not Found |
| 500 | Internal Server Error |
`,

  component: `# {title}

## Overview

{overview}

## Installation

\`\`\`bash
npm install {package}
\`\`\`

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
{props}

## Usage

\`\`\`tsx
{usage}
\`\`\`

## Accessibility

- Follows WAI-ARIA guidelines
- Keyboard navigable
- Screen reader compatible
`,

  guide: `# {title}

## Introduction

{introduction}

## Prerequisites

- Node.js 18+
- Package manager (npm/yarn/pnpm)

## Step-by-Step Guide

{steps}

## Troubleshooting

### Common Issues

{troubleshooting}

## FAQ

{faq}
`,

  reference: `# {title}

## Overview

{overview}

## API Reference

{api}

## Examples

{examples}

## Related

{related}
`,
};

function generateDocContent(doc: DocItem): string {
  const template = TEMPLATES[doc.type] || TEMPLATES.reference;

  return template
    .replace("{title}", doc.title)
    .replace("{overview}", `Documentation for ${doc.title}.`)
    .replace("{introduction}", `This guide covers ${doc.title}.`)
    .replace("{endpoints}", "<!-- Endpoints will be generated by codex-cli -->")
    .replace("{example}", `// Example usage of ${doc.title}`)
    .replace("{props}", "| - | - | - | - |")
    .replace("{usage}", `<${doc.title.replace(/\s/g, "")} />`)
    .replace(
      "{steps}",
      "### Step 1\n\nConfigure the module.\n\n### Step 2\n\nImplement the feature.",
    )
    .replace("{troubleshooting}", "Check configuration and dependencies.")
    .replace(
      "{faq}",
      "**Q: How do I get started?**\n\nA: Follow the step-by-step guide above.",
    )
    .replace("{api}", "See source code for detailed API.")
    .replace("{examples}", "```typescript\n// Example code\n```")
    .replace("{related}", `- [Related Documentation](./README.md)`)
    .replace(
      "{package}",
      doc.source_files[0]
        ?.split("/")
        .pop()
        ?.replace(/\.[^.]+$/, "") || "package",
    );
}

async function loadPlan(planPath: string): Promise<DocPlan> {
  const content = await readFile(planPath, "utf-8");
  return JSON.parse(content);
}

async function generateDocs(
  planPath: string,
  outputDir: string,
  filter?: string,
): Promise<GenerationStatus> {
  const plan = await loadPlan(planPath);
  const status: GenerationStatus = {
    last_run: new Date().toISOString(),
    documents: {},
    statistics: {
      total: 0,
      generated: 0,
      pending: 0,
      failed: 0,
    },
  };

  // Filter documents
  let docs = plan.documents;
  if (filter) {
    const regex = new RegExp(filter.replace("*", ".*"));
    docs = docs.filter((d) => regex.test(d.id) || regex.test(d.type));
  }

  status.statistics.total = docs.length;

  // Generate in order
  for (const docId of plan.generation_order) {
    const doc = docs.find((d) => d.id === docId);
    if (!doc) continue;

    const outputPath = join(outputDir, doc.path);

    try {
      // Generate content
      const content = generateDocContent(doc);

      // Ensure directory exists
      await mkdir(dirname(outputPath), { recursive: true });

      // Write file
      await writeFile(outputPath, content, "utf-8");

      status.documents[doc.id] = {
        status: "generated",
        generated_at: new Date().toISOString(),
        output_path: outputPath,
        word_count: content.split(/\s+/).length,
      };
      status.statistics.generated++;

      console.log(`Generated: ${doc.path}`);
    } catch (err) {
      status.documents[doc.id] = {
        status: "failed",
        output_path: outputPath,
        error: String(err),
      };
      status.statistics.failed++;
      console.error(`Failed: ${doc.path} - ${err}`);
    }
  }

  status.statistics.pending =
    status.statistics.total -
    status.statistics.generated -
    status.statistics.failed;

  return status;
}

// CLI
const planPath = process.argv[2] || ".claude/memory/docs/plan.json";
const outputDir = process.argv[3] || ".";
const filter = process.argv[4];

generateDocs(planPath, outputDir, filter)
  .then(async (status) => {
    const statusPath = ".claude/memory/docs/generation-status.json";
    await mkdir(dirname(statusPath), { recursive: true });
    await writeFile(statusPath, JSON.stringify(status, null, 2), "utf-8");

    console.log("\nGeneration complete:");
    console.log(`  Total: ${status.statistics.total}`);
    console.log(`  Generated: ${status.statistics.generated}`);
    console.log(`  Failed: ${status.statistics.failed}`);
    console.log(`\nStatus saved to: ${statusPath}`);
  })
  .catch((err) => {
    console.error("Generation failed:", err);
    process.exit(1);
  });
