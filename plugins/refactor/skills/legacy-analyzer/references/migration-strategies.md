# Migration Strategies - 迁移策略选择指南

## 策略决策树

```
                    ┌─────────────────────┐
                    │  项目规模和复杂度?   │
                    └─────────┬───────────┘
                              │
            ┌─────────────────┼─────────────────┐
            │                 │                 │
        小型项目          中型项目          大型项目
        (<10k LOC)     (10k-100k LOC)     (>100k LOC)
            │                 │                 │
            ▼                 ▼                 ▼
    ┌───────────────┐ ┌───────────────┐ ┌───────────────┐
    │  Big Bang?    │ │ 架构边界清晰?  │ │ Strangler Fig │
    └───────┬───────┘ └───────┬───────┘ └───────────────┘
            │                 │
       是   │   否       是   │   否
            ▼                 ▼
    完全重写      Strangler    先解耦再迁移
                   Fig
```

---

## 策略详解

### 1. Strangler Fig Pattern（绞杀者模式）

**适用场景**：

- 大型单体应用，无法一次性重写
- 业务持续运营，不能停机
- 需要渐进式风险控制
- 团队需要时间学习新技术

**实施阶段**：

| 阶段          | 活动                           | 风险      | 产出         |
| ------------- | ------------------------------ | --------- | ------------ |
| 1. 引入路由层 | 部署 API Gateway/Reverse Proxy | 🟢 Low    | 流量可观测   |
| 2. 识别接缝   | 领域分析，找出可独立替换的模块 | 🟢 Low    | 迁移路线图   |
| 3. 并行运行   | 新旧服务同时运行，渐进切流量   | 🟡 Medium | 双系统运行   |
| 4. 功能迁移   | 逐模块实现并替换               | 🟡 Medium | 新服务上线   |
| 5. 数据同步   | 确保数据一致性                 | 🔶 High   | 数据迁移完成 |
| 6. 下线遗留   | 确认无流量后下线旧系统         | 🟢 Low    | 完成迁移     |

**关键检查点**：

- [ ] API Gateway 已部署
- [ ] 流量可按路由规则分发
- [ ] 监控告警已配置
- [ ] 回滚方案已验证
- [ ] 数据同步机制已就绪

---

### 2. Big Bang Rewrite（完全重写）

**适用场景**：

- 小型简单系统
- 遗留代码质量极差，无法重构
- 技术债务过重，维护成本已超过重写成本
- 团队对新技术已有足够能力

**风险**：

- 🔴 **Critical** - 最高风险策略
- 需要冻结需求直到完成
- 容易低估工作量
- 可能丢失隐含业务知识

**缓解措施**：

1. 完整的需求文档
2. 充足的测试覆盖（E2E 测试）
3. 短迭代周期
4. 频繁的用户验收

---

### 3. Service-by-Service（按服务迁移）

**适用场景**：

- 已有微服务架构基础
- 服务边界相对清晰
- 可独立部署和扩展

**迁移顺序原则**：

1. **外围服务优先** - 依赖少的边缘服务
2. **高价值优先** - 业务价值高、变更频繁的服务
3. **低风险优先** - 测试覆盖好、影响范围小的服务

**服务优先级评估矩阵**：

| 维度     | 权重 | 评分标准  |
| -------- | ---- | --------- |
| 依赖数量 | 30%  | 少 = 高分 |
| 业务价值 | 25%  | 高 = 高分 |
| 变更频率 | 20%  | 高 = 高分 |
| 测试覆盖 | 15%  | 高 = 高分 |
| 技术债务 | 10%  | 低 = 高分 |

---

### 4. Frontend-First（前端优先）

**适用场景**：

- 前端和后端相对独立
- 后端 API 已相对稳定
- 用户体验改进是主要目标

**实施步骤**：

1. 引入 BFF（Backend for Frontend）层
2. 逐页面/模块替换前端
3. 保持后端 API 不变
4. 后续再迁移后端

**优势**：

- 用户可见改进最快
- 风险相对可控
- 可逐步积累经验

---

### 5. 解耦优先（Decouple First）

**适用场景**：

- 高度耦合的单体
- 无法直接识别服务边界
- 需要先重构再迁移

**解耦步骤**：

```
Step 1: 识别模块边界
        ↓
Step 2: 引入模块接口
        ↓
Step 3: 隔离数据访问
        ↓
Step 4: 模块间通信标准化
        ↓
Step 5: 准备好后再迁移
```

**解耦技术**：
| 技术 | 用途 |
|------|------|
| 依赖注入 | 降低类间耦合 |
| 接口隔离 | 定义清晰边界 |
| 防腐层 | 隔离外部依赖 |
| 领域事件 | 异步解耦模块 |

---

## 策略选择决策表

| 条件                        | 推荐策略           | 原因                 |
| --------------------------- | ------------------ | -------------------- |
| LOC < 10k + 质量差          | Big Bang           | 重写成本低于维护     |
| LOC < 10k + 质量好          | Strangler Fig      | 保护投资，渐进改进   |
| 10k < LOC < 100k + 边界清晰 | Service-by-Service | 按服务拆分迁移       |
| 10k < LOC < 100k + 高耦合   | Decouple First     | 先解耦再迁移         |
| LOC > 100k                  | Strangler Fig      | 唯一可行的低风险策略 |
| 前后端独立                  | Frontend-First     | 快速见效，风险可控   |
| 已有微服务基础              | Service-by-Service | 顺势而为             |

---

## 迁移接缝（Seams）识别

### 什么是接缝？

接缝是系统中可以独立替换的功能边界，是 Strangler Fig 模式的关键。

### 识别方法

1. **API 边界分析**
   - 识别 REST/RPC 端点
   - 分析请求/响应契约

2. **数据流分析**
   - 识别独立数据域
   - 找出数据隔离点

3. **依赖图分析**
   - 构建模块依赖图
   - 找出低依赖子图

4. **业务领域分析**
   - 识别限界上下文
   - 映射业务能力

### 好的接缝特征

| 特征     | 说明               |
| -------- | ------------------ |
| 低入度   | 依赖它的模块少     |
| 低出度   | 它依赖的模块少     |
| 数据内聚 | 数据访问相对独立   |
| 业务完整 | 代表完整的业务能力 |
| 测试覆盖 | 有足够的测试保护   |

---

## 参考

- 父目录: `../../../references/legacy-modernization.md`
- Martin Fowler - Strangler Fig Application
- Sam Newman - Building Microservices
- Michael Feathers - Working Effectively with Legacy Code
